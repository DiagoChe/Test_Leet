方法三：扫描法――O(N)
当我们加上一个正数时，和会增加；当我们加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。

    据说这道题是《编程珠机》里面的题目，叫做扫描法，速度最快，扫描一次就求出结果，复杂度是O（n）。书中说，这个算法是一个统计学家提出的。

    这个算法如此精炼简单，而且复杂度只有线性。但是我想，能想出来却非常困难，而且证明也不简单。在这里，我斗胆写出自己证明的想法：

    关于这道题的证明，我的思路是去证明这样的扫描法包含了所有n^2种情况，即所有未显示列出的子数组都可以在本题的扫描过程中被抛弃。

    1 首先，假设算法扫描到某个地方时，始终未出现加和小于等于0的情况。

    我们可以把所有子数组（实际上为当前扫描过的元素所组成的子数组）列为三种：

    1.1 以开头元素为开头，结尾为任一的子数组

    1.2 以结尾元素为结尾，开头为任一的子数组

    1.3 开头和结尾都不等于当前开头结尾的所有子数组

    1.1由于遍历过程中已经扫描，所以算法已经考虑了。1.2确实没考虑，但我们随便找到1.2中的某一个数组，可知，从开头元素到这个1.2中的数组的加和大于0（因为如果小于0就说明扫描过程中遇到小于0的情况，不包括在大前提1之内），那么这个和一定小于从开头到这个1.2数组结尾的和。故此种情况可舍弃

    1.3 可以以1.2同样的方法证明，因为我们的结尾已经列举了所有的情况，那么每一种情况和1.2是相同的，故也可以舍弃。

    2 如果当前加和出现小于等于0的情况，且是第一次出现，可知前面所有的情况加和都不为0

    一个很直观的结论是，如果子段和小于0，我们可以抛弃，但问题是是不是他的所有以此子段结尾为结尾而开头任意的子段也需要抛弃呢？

    答案是肯定的。因为以此子段开头为开头而结尾任意的子段加和都大于0（情况2的前提），所以这些子段的和是小于当前子段的，也就是小于0的，对于后面也是需要抛弃的。也就是说，所有以之前的所有元素为开头而以当前结尾之后元素为结尾的数组都可以抛弃了。

    而对于后面抛弃后的数组，则可以同样递归地用1 2两个大情况进行分析，于是得证。
